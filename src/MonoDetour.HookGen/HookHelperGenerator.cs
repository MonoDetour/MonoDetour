using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using MonoMod.SourceGen.Internal;
using MonoMod.SourceGen.Internal.Helpers;

namespace MonoDetour.HookGen
{
    // TODO: finish support for unnameable types

    [Generator]
    public sealed class HookHelperGenerator : IIncrementalGenerator
    {
        // NOTE: keep this in sync with the injected source below
        private enum DetourKind
        {
            Hook = 0,
            ILHook = 1,
            Both = 2,
        }

        public const string GenHelperForTypeAttributeFqn =
            "MonoDetour.HookGen.MonoDetourTargetsAttribute";
        private const string ILHookParameterType = "global::MonoMod.Cil.ILContext.Manipulator";
        public const string GenHelperForTypeAttrFile = "GenerateHookHelpersAttribute.g.cs";
        public const string DelegateTypesFile = "DelegateTypes.g.cs";
        public const string GenHelperForTypeAttributeSource = """
            // <auto-generated />
            #nullable enable

            using System;
            using System.Diagnostics;

            namespace MonoDetour.HookGen
            {
            #if DEBUG
                /// <summary>
                /// Contains the default MonoDetourManager generated for this assembly
                /// and a helper method for creating new instances using the default values.
                /// </summary>
            #endif
                internal static class DefaultMonoDetourManager
                {
            #if DEBUG
                    /// <summary>
                    /// The default MonoDetourManager instance generated for this assembly.<br/>
                    /// This automatically used when none is specified.
                    /// </summary>
            #endif
                    internal static global::MonoDetour.MonoDetourManager Instance { get; } = New();

            #if DEBUG
                    /// <summary>
                    /// Creates a new MonoDetourManager instance using the assembly name.
                    /// </summary>
            #endif
                    internal static global::MonoDetour.MonoDetourManager New() =>
                        new(typeof(DefaultMonoDetourManager).Assembly.GetName().Name!);
                }

            #if DEBUG
                /// <summary>
                /// Specifies that:
                /// <list type="bullet">
                ///   <item>
                ///     MonoDetour.HookGen will generate hooks for the targetTypes specified
                ///   </item>
                ///   <item>
                ///     <see cref="MonoDetourManager.InvokeHookInitializers()"/>
                ///     will invoke static methods marked with <see cref="MonoDetourHookInitializeAttribute"/> in types with this attribute
                ///   </item>
                /// </list>
                /// </summary>
                /// <param name="targetType">The type to generate hook helpers for.</param>
                /// <remarks>
                /// Non-public members of the type may or may not be included.
                /// It is recommended to use a publicizer with MonoDetour's hook generator.
                /// </remarks>
            #endif
                [AttributeUsage(
                    AttributeTargets.Assembly | AttributeTargets.Class,
                    AllowMultiple = true,
                    Inherited = false
                )]
                internal class MonoDetourTargetsAttribute(Type? targetType = null) : global::System.Attribute, global::MonoDetour.IMonoDetourTargets
                {
                    /// <summary>
                    /// The type to generate hook helpers for the members of.
                    /// </summary>
                    public global::System.Type? TargetType { get; } = targetType;

                    // public DetourKind Kind { get; set; } = DetourKind.Hook;

                    /// <summary>
                    /// Whether to generate helpers for nested types. Defaults to <see langword="true"/>.
                    /// </summary>
                    public bool IncludeNestedTypes { get; set; } = true;

                    /// <summary>
                    /// Whether to differentiate between overloaded members by putting their (sanitized) signature in the generated name.
                    /// Defaults to <see langword="false"/>.
                    /// </summary>
                    public bool DistinguishOverloadsByName { get; set; }

                    /// <summary>
                    /// A list of members to generate hook helpers for in the target type, by exact name.
                    /// All members with the specified names (including overloads) will be generated.
                    /// </summary>
                    public string[]? Members { get; set; }

                    /// <summary>
                    /// A list of member name prefixes to match members against. Members whose names have one of these
                    /// prefixes will be included.
                    /// </summary>
                    public string[]? MemberNamePrefixes { get; set; }

                    /// <summary>
                    /// A list of member name suffixes to match members against. Members whose names have one of these
                    /// suffixes will be included.
                    /// </summary>
                    public string[]? MemberNameSuffixes { get; set; }

                    /// <summary>
                    /// Whether or not MonoDetour will generate variants of the hooks which can affect control flow of
                    /// the target methods. Defaults to <see langword="false"/>.
                    /// </summary>
                    public bool GenerateControlFlowVariants { get; set; }
                }
            }
            """;

        private static readonly ObjectPool<
            Dictionary<MetadataReference, ImmutableArrayBuilder<AttributeModel>>
        > asmIdentBuilderDictPool = new(() => new());
        private static readonly ObjectPool<
            Dictionary<TypeContext, ImmutableArrayBuilder<AttributeModel>>
        > typeIdentBuilderDictPool = new(() => new());
        private static readonly ObjectPool<
            Dictionary<(DetourKind, bool, bool, bool), InProgressTypeModel>
        > inProgressTypeModelDictPool = new(() => new());

        private static readonly ObjectPool<HashSet<string>> stringHashSetPool = new(() => new());
        private static readonly ObjectPool<HashSet<MethodSignature>> methodSigHashSetPool = new(
            () => new()
        );
        private static readonly ObjectPool<HashSet<TypeRef>> typeRefHashSetPool = new(() => new());
        private static readonly ObjectPool<
            HashSet<(GeneratableMemberModel, GeneratableTypeModel)>
        > membersToGenerateForTypesPool = new(() => new());

        private static readonly ObjectPool<Queue<GeneratableTypeModel>> genTypeModelQueuePool = new(
            () => new()
        );

        private static readonly IEqualityComparer<HashSet<string>> stringHashSetEqualityComparer =
            HashSet<string>.CreateSetComparer();

        private sealed record LanguageSupportOptions(
            bool FileLocalTypes,
            bool CollectionExpressions
        );

        private sealed record BclSupportOptions(bool DoesNotReturnAttribute);

        private sealed record ContextSupportOptions(
            LanguageSupportOptions Lang,
            BclSupportOptions Bcl
        );

        private sealed class InProgressTypeModel(
            HashSet<string>? MemberNames,
            HashSet<string>? MemberPrefixes,
            HashSet<string>? MemberSuffixes
        )
        {
            public HashSet<string>? MemberNames { get; set; } = MemberNames;
            public HashSet<string>? MemberPrefixes { get; set; } = MemberPrefixes;
            public HashSet<string>? MemberSuffixes { get; set; } = MemberSuffixes;
        }

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            context.RegisterPostInitializationOutput(ctx =>
            {
                ctx.AddSource(GenHelperForTypeAttrFile, GenHelperForTypeAttributeSource);
            });

            var langSupport = context.ParseOptionsProvider.Select(
                (options, ct) =>
                {
                    var csOpts = (CSharpParseOptions)options;
                    var langVer = csOpts.LanguageVersion;
                    return new LanguageSupportOptions(
                        langVer >= LanguageVersion.CSharp11,
                        langVer >= LanguageVersion.CSharp12
                    );
                }
            );

            var bclSupport = context.CompilationProvider.Select(
                (c, ct) =>
                {
                    return new BclSupportOptions(
                        c.GetTypeByMetadataName(
                            "System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute"
                        )
                            is not null
                    );
                }
            );

            var support = langSupport
                .Combine(bclSupport)
                .Select((t, ct) => new ContextSupportOptions(t.Left, t.Right));

            var attributes = context
                .SyntaxProvider.ForAttributeWithMetadataName(
                    GenHelperForTypeAttributeFqn,
                    static (_, _) => true,
                    static (ctx, ct) =>
                    {
                        using var builder = ImmutableArrayBuilder<AttributeModel>.Rent();

                        foreach (var attr in ctx.Attributes)
                        {
                            ct.ThrowIfCancellationRequested();
                            var model = ReadTypeModelForAttribute(
                                ctx.SemanticModel.Compilation,
                                ctx.TargetSymbol,
                                attr
                            );
                            if (model is not null)
                            {
                                builder.Add(model);
                            }
                        }

                        return builder.ToImmutable();
                    }
                )
                .SelectMany(static (x, _) => x);

            // all attributes are now available, we now want to group them by target assembly and target type
            var groupedByAssembly = attributes
                .Collect()
                .SelectMany(
                    (attrs, ct) =>
                    {
                        var dict = asmIdentBuilderDictPool.Allocate();

                        foreach (var attr in attrs)
                        {
                            ct.ThrowIfCancellationRequested();

                            if (!dict.TryGetValue(attr.TargetAssembly, out var asmBuilder))
                            {
                                dict.Add(
                                    attr.TargetAssembly,
                                    asmBuilder = ImmutableArrayBuilder<AttributeModel>.Rent()
                                );
                            }

                            asmBuilder.Add(attr);
                        }

                        using var builder = ImmutableArrayBuilder<(
                            MetadataReference Assembly,
                            EquatableArray<AttributeModel> Attributes
                        )>.Rent();

                        foreach (var kvp in dict)
                        {
                            ct.ThrowIfCancellationRequested();
                            builder.Add((kvp.Key, kvp.Value.ToImmutable()));
                            kvp.Value.Dispose();
                        }

                        dict.Clear();
                        asmIdentBuilderDictPool.Free(dict);

                        return builder.ToImmutable();
                    }
                );

            // now for each assembly, we want to group by type
            var groupedByType = groupedByAssembly.Select(
                (t, ct) =>
                {
                    var dict = typeIdentBuilderDictPool.Allocate();

                    foreach (var attr in t.Attributes)
                    {
                        ct.ThrowIfCancellationRequested();

                        if (!dict.TryGetValue(attr.TargetType, out var asmBuilder))
                        {
                            dict.Add(
                                attr.TargetType,
                                asmBuilder = ImmutableArrayBuilder<AttributeModel>.Rent()
                            );
                        }

                        asmBuilder.Add(attr);
                    }

                    using var builder = ImmutableArrayBuilder<TypeModel>.Rent();

                    foreach (var kvp in dict)
                    {
                        ct.ThrowIfCancellationRequested();
                        builder.Add(new(kvp.Key, kvp.Value.ToImmutable()));
                        kvp.Value.Dispose();
                    }

                    dict.Clear();
                    typeIdentBuilderDictPool.Free(dict);

                    return new AssemblyModel(t.Assembly, builder.ToImmutable());
                }
            );

            // then, for each type, we want to unify the requested attribute options
            var unifiedGroupedByType = groupedByType.Select(
                (model, ct) =>
                {
                    using var typeModelBuilder = ImmutableArrayBuilder<TypeModel>.Rent();
                    using var attrsBuilder = ImmutableArrayBuilder<AttributeModel>.Rent();

                    foreach (var type in model.Types)
                    {
                        ct.ThrowIfCancellationRequested();
                        var dict = inProgressTypeModelDictPool.Allocate();

                        foreach (var attr in type.Attributes)
                        {
                            var tuple = (
                                attr.Options.Kind,
                                attr.Options.IncludeNested,
                                attr.Options.DistinguishOverloads,
                                attr.Options.GenerateControlFlowVariants
                            );
                            if (!dict.TryGetValue(tuple, out var inProgress))
                            {
                                dict.Add(
                                    tuple,
                                    inProgress = new(stringHashSetPool.Allocate(), null, null)
                                );
                            }

                            if (attr.Options.ExplicitMembers is null)
                            {
                                if (inProgress.MemberNames is not null)
                                {
                                    inProgress.MemberNames.Clear();
                                    stringHashSetPool.Free(inProgress.MemberNames);
                                }
                                inProgress.MemberNames = null;
                                if (inProgress.MemberPrefixes is not null)
                                {
                                    inProgress.MemberPrefixes.Clear();
                                    stringHashSetPool.Free(inProgress.MemberPrefixes);
                                }
                                inProgress.MemberPrefixes = null;
                                if (inProgress.MemberSuffixes is not null)
                                {
                                    inProgress.MemberSuffixes.Clear();
                                    stringHashSetPool.Free(inProgress.MemberSuffixes);
                                }
                                inProgress.MemberSuffixes = null;

                                break;
                            }

                            foreach (var name in attr.Options.ExplicitMembers)
                            {
                                _ = (inProgress.MemberNames ??= stringHashSetPool.Allocate()).Add(
                                    name
                                );
                            }
                            foreach (var name in attr.Options.MemberPrefixes)
                            {
                                _ = (
                                    inProgress.MemberPrefixes ??= stringHashSetPool.Allocate()
                                ).Add(name);
                            }
                            foreach (var name in attr.Options.MemberSuffixes)
                            {
                                _ = (
                                    inProgress.MemberSuffixes ??= stringHashSetPool.Allocate()
                                ).Add(name);
                            }
                        }

                        ct.ThrowIfCancellationRequested();

                        attrsBuilder.Clear();
                        foreach (var kvp in dict)
                        {
                            var prefixes = ImmutableArray<string>.Empty;
                            var suffixes = ImmutableArray<string>.Empty;

                            if (kvp.Value.MemberPrefixes is not null)
                            {
                                prefixes = kvp.Value.MemberPrefixes.ToImmutableArray();
                                kvp.Value.MemberPrefixes.Clear();
                                stringHashSetPool.Free(kvp.Value.MemberPrefixes);
                            }
                            if (kvp.Value.MemberSuffixes is not null)
                            {
                                suffixes = kvp.Value.MemberSuffixes.ToImmutableArray();
                                kvp.Value.MemberSuffixes.Clear();
                                stringHashSetPool.Free(kvp.Value.MemberSuffixes);
                            }

                            attrsBuilder.Add(
                                new(
                                    model.Assembly,
                                    type.TargetType,
                                    new(
                                        kvp.Key.Item1,
                                        kvp.Key.Item2,
                                        kvp.Key.Item3,
                                        kvp.Value.MemberNames,
                                        prefixes,
                                        suffixes,
                                        kvp.Key.Item4
                                    )
                                )
                            );
                        }
                        typeModelBuilder.Add(type with { Attributes = attrsBuilder.ToImmutable() });
                        attrsBuilder.Clear();
                        dict.Clear();
                        inProgressTypeModelDictPool.Free(dict);
                    }

                    return model with
                    {
                        Types = typeModelBuilder.ToImmutable(),
                    };
                }
            );

            // next, we want to go per-assembly, and perform the actual member lookups
            var mappedAssemblies = groupedByType
                .Combine(context.CompilationProvider)
                .Select(GetAssemblySymbol)
                .Where(t => t.Symbol is not null);

            var generatableAssemblies = mappedAssemblies.Select(GetAllMembersToGenerate!);

            var signaturesAndTypes = generatableAssemblies.Select(ExtractSignaturesAndTypes);

            var neededSignaturesWithDupes = signaturesAndTypes.SelectMany(
                (t, ct) => t.Item1.AsImmutableArray()
            );

            var neededSignaturesWithoutDupes = neededSignaturesWithDupes
                .Collect()
                .SelectMany(
                    (arr, ct) =>
                    {
                        var set = methodSigHashSetPool.Allocate();

                        foreach (var method in arr)
                        {
                            _ = set.Add(method);
                        }

                        var result = set.ToImmutableArray();
                        set.Clear();
                        methodSigHashSetPool.Free(set);
                        return result;
                    }
                );

            // context.RegisterSourceOutput(neededSignaturesWithoutDupes.Collect(), EmitDelegateTypes);

            var typesWithoutDupes = signaturesAndTypes
                .SelectMany((t, ct) => t.Item2.AsImmutableArray())
                .Collect()
                .SelectMany(
                    (arr, ct) =>
                    {
                        var set = typeRefHashSetPool.Allocate();

                        foreach (var type in arr)
                        {
                            _ = set.Add(type);
                        }

                        var result = set.ToImmutableArray();
                        set.Clear();
                        typeRefHashSetPool.Free(set);
                        return result;
                    }
                );

            var generatableTypesWithoutSupport = generatableAssemblies.SelectMany(
                (ass, ct) => ass.Types
            );

            var generatableTypes = generatableTypesWithoutSupport.Combine(support);

            // We only try to generate hook contents for hooks which are used.
            var memberNameToModel = generatableTypesWithoutSupport
                .Collect()
                .Select(
                    (types, ct) =>
                    {
                        Dictionary<
                            string,
                            List<(GeneratableMemberModel, GeneratableTypeModel)>
                        > memberNameToModel = [];

                        foreach (var type in types)
                        {
                            foreach (var member in type.Members)
                            {
                                if (memberNameToModel.TryGetValue(member.Name, out var members))
                                {
                                    members.Add((member, type));
                                }
                                else
                                {
                                    memberNameToModel.Add(member.Name, [(member, type)]);
                                }
                            }
                        }

                        Dictionary<
                            string,
                            ImmutableArray<(GeneratableMemberModel, GeneratableTypeModel)>
                        > retMemberNameToModel = [];

                        foreach (var kv in memberNameToModel)
                        {
                            retMemberNameToModel.Add(kv.Key, [.. kv.Value]);
                        }

                        return retMemberNameToModel.ToImmutableDictionary();
                    }
                );

            var methodsToAnalyze = context.SyntaxProvider.CreateSyntaxProvider(
                predicate: static (node, _) => node is MethodDeclarationSyntax,
                transform: static (ctx, _) =>
                {
                    var methodSyntax = (MethodDeclarationSyntax)ctx.Node;

                    var symbol = ctx.SemanticModel.GetDeclaredSymbol(methodSyntax);
                    return symbol;
                }
            );

            var membersToGenerateForTypes = methodsToAnalyze.Combine(memberNameToModel);

            var membersToGenerateHookContentsFor = membersToGenerateForTypes
                .Select(
                    (items, ct) =>
                    {
                        var (methodSymbol, memberNameToModel) = items;

                        if (methodSymbol is null)
                            return [];

                        if (
                            methodSymbol!.DeclaringSyntaxReferences.FirstOrDefault()?.GetSyntax()
                            is not MethodDeclarationSyntax methodSyntax
                        )
                        {
                            return [];
                        }

                        return GetReferencedHookGenHooks(memberNameToModel, methodSyntax);
                    }
                )
                .Collect() // first, get all lists of used hook gen classes
                .Select( // now we can deduplicate
                    (arr, ct) =>
                    {
                        var set = membersToGenerateForTypesPool.Allocate();

                        foreach (var modelArrays in arr)
                        {
                            foreach (var modelArray in modelArrays)
                            {
                                foreach (var (method, type) in modelArray)
                                {
                                    set.Add((method, type));

                                    // sb.Append("// added: ")
                                    //     .Append(res ? "yes " : "NO ")
                                    //     .Append(type.Type.FullContextName)
                                    //     .Append(" ")
                                    //     .Append(type.GetHashCode())
                                    //     .Append(" : ")
                                    //     .Append(method.Name)
                                    //     .Append(" ")
                                    //     .AppendLine(method.GetHashCode().ToString());
                                }
                            }
                        }

                        var result = set.ToImmutableArray();
                        set.Clear();
                        membersToGenerateForTypesPool.Free(set);
                        return result;
                    }
                )
                .SelectMany((x, _) => x);

            context.RegisterSourceOutput(
                membersToGenerateHookContentsFor.Combine(support),
                EmitHelperTypeWithContent
            );

            context.RegisterSourceOutput(generatableTypes, EmitHelperTypeStub);
        }

        static ImmutableArray<
            ImmutableArray<(GeneratableMemberModel, GeneratableTypeModel)>
        > GetReferencedHookGenHooks(
            ImmutableDictionary<
                string,
                ImmutableArray<(GeneratableMemberModel, GeneratableTypeModel)>
            > memberNameToModel,
            MethodDeclarationSyntax methodSyntax
        )
        {
            var usedClasses =
                new HashSet<ImmutableArray<(GeneratableMemberModel, GeneratableTypeModel)>>();

            foreach (
                var access in methodSyntax.DescendantNodes().OfType<MemberAccessExpressionSyntax>()
            )
            {
                // Matches: Type.Method()
                // Doesn't match: Type.Method
                // Doesn't match: Type
                if (TryAddType(GetFullName(access.Expression)))
                    continue;
            }

            foreach (
                var identifier in methodSyntax.DescendantNodes().OfType<IdentifierNameSyntax>()
            )
            {
                TryAddType(identifier.Identifier.Text);
            }

            bool TryAddType(string? typeName)
            {
                if (typeName is null)
                    return false;

                if (memberNameToModel.TryGetValue(typeName, out var model))
                {
                    usedClasses.Add(model);
                    return true;
                }

                return false;
            }

            string? GetFullName(ExpressionSyntax? expr)
            {
                if (expr is null)
                    return null;

                var parts = new Stack<string>();

                while (expr is MemberAccessExpressionSyntax member)
                {
                    parts.Push(member.Name.Identifier.Text);
                    expr = member.Expression;
                }

                if (expr is IdentifierNameSyntax id)
                {
                    parts.Push(id.Identifier.Text);
                }
                else
                {
                    return null;
                }

                return string.Join(".", parts);
            }

            return [.. usedClasses.ToImmutableArray()];
        }

        private void EmitHelperTypeWithContent(
            SourceProductionContext context,
            ((GeneratableMemberModel, GeneratableTypeModel), ContextSupportOptions) input
        )
        {
            var (items, ctx) = input;
            var (model, type) = items;

            try
            {
                var sb = new StringBuilder();
                var cb = new CodeBuilder(sb);

                // TODO: check if this works with overloads (it doesn't),
                // then remove these commented out lines.

                // foreach (var usedClassMemberModel in usedClassMemberModels)
                // {
                cb.WriteHeader();

                WriteTrowHelperClassIfCan(cb, ctx);

                // foreach (var (model, type) in usedClassMemberModels)
                // {
                cb.WriteLine("namespace On").OpenBlock();

                type.Type.AppendEnterContext(cb);

                EmitTypeMember(type, model, cb, il: false, ctx, generateContent: true);

                type.Type.AppendExitContext(cb);

                cb.CloseBlock().WriteLine();

                StringBuilder nameSb = new();
                CodeBuilder nameCb = new(nameSb);
                nameCb
                    .Write(type.AssemblyIdentity.Name)
                    .Write('_')
                    .Write(SanitizeMdName(type.Type.FullContextName).Replace(' ', '_'))
                    .Write('.');

                if (model.HasOverloads)
                {
                    AppendSignatureIdentifier(nameCb, model.Signature);
                }
                else
                {
                    nameCb.Write(SanitizeMdName(model.Name).Replace(' ', '_'));
                }

                nameCb.Write(".g.cs");

                context.AddSource(nameCb.ToString(), SourceText.From(cb.ToString(), Encoding.UTF8));
                // }
            }
            catch (ArgumentException ex)
            {
                throw new Exception($"{ex.Message}: {ex.StackTrace}".Replace('\n', '/'));
            }
        }

        private void EmitHelperTypeStub(
            SourceProductionContext context,
            (GeneratableTypeModel, ContextSupportOptions) input
        )
        {
            try
            {
                var (type, ctx) = input;

                var sb = new StringBuilder();
                var cb = new CodeBuilder(sb);

                cb.WriteHeader();

                if (type.HasHook)
                {
                    cb.WriteLine("namespace On").OpenBlock();

                    type.Type.AppendEnterContext(cb);

                    EmitTypeMembers(type, cb, il: false, ctx, generateContent: false);

                    type.Type.AppendExitContext(cb);

                    cb.CloseBlock().WriteLine();
                }

                string fileName =
                    $"{type.AssemblyIdentity.Name}_{SanitizeMdName(type.Type.FullContextName).Replace(' ', '_')}.g.cs";

                context.AddSource(fileName, sb.ToString());
            }
            catch (Exception ex)
            {
                throw new Exception($"{ex.Message}: {ex.StackTrace}".Replace('\n', '/'));
            }
        }

        static void WriteTrowHelperClassIfCan(CodeBuilder cb, ContextSupportOptions ctx)
        {
            if (ctx.Lang.FileLocalTypes)
            {
                cb.WriteLine("file static class ThrowHelper").OpenBlock();

                if (ctx.Bcl.DoesNotReturnAttribute)
                {
                    cb.WriteLine(
                        "[global::System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute]"
                    );
                }

                cb.WriteLine("public static void ThrowMissingMethod(string type, string method)")
                    .OpenBlock()
                    .WriteLine("throw new global::System.MissingMethodException(type, method);")
                    .CloseBlock();

                if (ctx.Bcl.DoesNotReturnAttribute)
                {
                    cb.WriteLine(
                        "[global::System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute]"
                    );
                }

                cb.WriteLine("public static void ThrowMissingType(string type)")
                    .OpenBlock()
                    .WriteLine(
                        "throw new global::System.Exception($\"Missing Type: '{type}'. This exception should go away by recompiling against latest assembly references.\");"
                    )
                    .CloseBlock();

                cb.CloseBlock();
            }
        }

        private static void EmitThrowMissing(
            GeneratableTypeModel type,
            GeneratableMemberModel? member,
            CodeBuilder cb,
            ContextSupportOptions ctx,
            bool force = false
        )
        {
            if (force || !ctx.Lang.FileLocalTypes)
            {
                if (member is { })
                {
                    cb.Write("throw new global::System.MissingMethodException(\"")
                        .Write(type.Type.InnermostType.MdName)
                        .Write("\", \"")
                        .Write(member.Name)
                        .WriteLine("\");");
                }
                else
                {
                    cb.Write("throw new global::System.Exception(\"")
                        .Write("Missing Type: '")
                        .Write(type.Type.InnermostType.MdName)
                        .Write(
                            "'. This exception should go away by recompiling against latest assembly references."
                        )
                        .WriteLine("\");");
                }
            }
            else
            {
                if (member is { })
                {
                    cb.Write("ThrowHelper.ThrowMissingMethod(\"")
                        .Write(type.Type.InnermostType.MdName)
                        .Write("\", \"")
                        .Write(member.Name)
                        .WriteLine("\");");
                }
                else
                {
                    cb.Write("ThrowHelper.ThrowMissingType(\"")
                        .Write(type.Type.InnermostType.MdName)
                        .WriteLine("\");");
                }
            }
        }

        private static void EmitTypeMembers(
            GeneratableTypeModel type,
            CodeBuilder cb,
            bool il,
            ContextSupportOptions ctx,
            bool generateContent
        )
        {
            foreach (var member in type.Members)
            {
                EmitTypeMember(type, member, cb, il, ctx, generateContent);
            }

            foreach (var nested in type.NestedTypes)
            {
                if (il)
                {
                    if (!nested.HasIl)
                    {
                        continue;
                    }
                }
                else
                {
                    if (!nested.HasHook)
                    {
                        continue;
                    }
                }

                cb.Write("internal static ")
                    .Write(nested.Type.ContainingTypeDecls[0])
                    .WriteLine()
                    .OpenBlock();

                EmitTypeMembers(nested, cb, il, ctx, generateContent);

                cb.CloseBlock();
            }
        }

        private static void EmitTypeMember(
            GeneratableTypeModel type,
            GeneratableMemberModel member,
            CodeBuilder cb,
            bool il,
            ContextSupportOptions ctx,
            bool generateContent
        )
        {
            if (il)
            {
                if (member.Kind == DetourKind.Hook)
                {
                    return;
                }
            }
            else
            {
                if (member.Kind == DetourKind.ILHook)
                {
                    return;
                }
            }

            var bindingFlags = member.Accessibility switch
            {
                Accessibility.NotApplicable => BindingFlags.NonPublic,
                Accessibility.Private => BindingFlags.NonPublic,
                Accessibility.ProtectedAndInternal => BindingFlags.NonPublic,
                Accessibility.Protected => BindingFlags.NonPublic,
                Accessibility.Internal => BindingFlags.NonPublic,
                Accessibility.ProtectedOrInternal => BindingFlags.NonPublic,
                Accessibility.Public => BindingFlags.Public,
                _ => BindingFlags.NonPublic,
            };

            bindingFlags |= member.Signature.ThisType is null
                ? BindingFlags.Static
                : BindingFlags.Instance;

            var hookType = "global::MonoDetour.MonoDetourHook";
            var parameterType = il
                ? ILHookParameterType
                : "global::MonoMod.HookGen." + GetHookDelegateName(member.Signature);

            cb.Write("internal static partial class ").Write(SanitizeName(member.Name));

            if (member.HasOverloads || member.DistinguishByName)
            {
                AppendSignatureIdentifier(cb, member.Signature);
            }
            cb.WriteLine().OpenBlock();

            if (!generateContent)
            {
                cb.CloseBlock();
                return;
            }

            var sig = member.Signature;
            var parameters = sig.ParameterTypes.AsImmutableArray();

            CodeBuilder WriteDelegateTypes()
            {
                if (sig.ThisType is { } thisType2)
                {
                    _ = cb.Write(SanitizeUnspeakableFqName(RemoveRefness(thisType2.FqName)))
                        .Write(" self");
                }

                for (var i = 0; i < parameters.Length; i++)
                {
                    var param = parameters[i];

                    if (i != 0 || sig.ThisType is not null)
                    {
                        _ = cb.WriteLine(",");
                    }

                    cb.Write("ref ")
                        .Write(SanitizeUnspeakableFqName(RemoveRefness(param.FqName)))
                        .Write(' ')
                        .Write(SanitizeMdName(param.ParamName!));
                }

                return cb;
            }

            cb.Write("public delegate void PrefixSignature(").IncreaseIndent();
            WriteDelegateTypes();
            cb.WriteLine(");").DecreaseIndent();

            if (member.GenerateControlFlowVariants)
            {
                cb.WriteLine(
                        "public delegate global::MonoDetour.DetourTypes.ReturnFlow ControlFlowPrefixSignature("
                    )
                    .IncreaseIndent();
                WriteDelegateTypes();
                WriteReturnValueIfExists();
                cb.WriteLine(");").DecreaseIndent();
            }

            cb.Write("public delegate void PostfixSignature(").IncreaseIndent();
            WriteDelegateTypes();
            WriteReturnValueIfExists();
            cb.WriteLine(");").DecreaseIndent().WriteLine();

            void WriteReturnValueIfExists()
            {
                if (member.Signature.ReturnType.FqName != "void")
                {
                    if (parameters.Length != 0 || sig.ThisType is not null)
                    {
                        _ = cb.WriteLine(",");
                    }
                    cb.Write("ref ")
                        .Write(
                            SanitizeUnspeakableFqName(
                                RemoveRefness(member.Signature.ReturnType.FqName)
                            )
                        )
                        .Write(" returnValue");
                }
            }

            if (member.Signature.IteratorStateMachine is { } iterator)
            {
                var genericEnumerator =
                    "global::MonoDetour.Reflection.Unspeakable.SpeakableEnumerator";

                cb.Write("public delegate void PrefixMoveNextSignature(")
                    .Write(genericEnumerator)
                    .Write('<')
                    .Write(iterator.EnumeratorType.FqName);
                if (iterator.ThisField)
                {
                    cb.Write(", ").Write(type.Type.InnermostType.FqName);
                }
                cb.WriteLine("> self);").WriteLine();

                if (member.GenerateControlFlowVariants)
                {
                    cb.Write(
                            "public delegate global::MonoDetour.DetourTypes.ReturnFlow ControlFlowPrefixMoveNextSignature("
                        )
                        .Write(genericEnumerator)
                        .Write('<')
                        .Write(iterator.EnumeratorType.FqName);
                    if (iterator.ThisField)
                    {
                        cb.Write(", ").Write(type.Type.InnermostType.FqName);
                    }
                    cb.WriteLine("> self);").WriteLine();
                }
                cb.Write("public delegate void PostfixMoveNextSignature(")
                    .Write(genericEnumerator)
                    .Write('<')
                    .Write(iterator.EnumeratorType.FqName);
                if (iterator.ThisField)
                {
                    cb.Write(", ").Write(type.Type.InnermostType.FqName);
                }
                cb.WriteLine("> self, ref bool continueEnumeration);").WriteLine();
            }

            void PrintIEnumeratorWarning(string correspondingIEnumeratorHook)
            {
                cb.WriteLine("#if DEBUG")
                    .WriteLine(
                        "/// <remarks>WARNING: The target method is an IEnumerator"
                            + " which is a method that returns a state machine."
                            + " This hook would run before the state machine is enumerated with MoveNext()."
                    )
                    .WriteLine("/// <br/><br/>")
                    .Write("/// The hook you are probably looking for would be ")
                    .Write(correspondingIEnumeratorHook)
                    .WriteLine(".")
                    .WriteLine(
                        "/// See http://monodetour.github.io/hooking/ienumerators/ for more information.</remarks>"
                    )
                    .WriteLine("#endif");
            }

            WriteHooks(forMoveNext: false);

            if (member.Signature.IteratorStateMachine is not null)
            {
                WriteHooks(forMoveNext: true);
            }

            void WriteHooks(bool forMoveNext)
            {
                bool warnIEnumerator =
                    !forMoveNext && member.Signature.IteratorStateMachine is not null;

                if (warnIEnumerator)
                    PrintIEnumeratorWarning("MoveNextPrefix");

                cb.Write("public static ").Write(hookType).Write("<PrefixDetour> ");
                if (forMoveNext)
                    cb.Write("PrefixMoveNext(PrefixMoveNextSignature hook, ");
                else
                    cb.Write("Prefix(PrefixSignature hook, ");
                cb.WriteLine(
                        "global::MonoDetour.MonoDetourConfig? config = null, bool applyByDefault = true, global::MonoDetour.MonoDetourManager? manager = null) =>"
                    )
                    .IncreaseIndent()
                    .WriteLine(
                        "(manager ?? global::MonoDetour.HookGen.DefaultMonoDetourManager.Instance)"
                    )
                    .IncreaseIndent();
                if (forMoveNext)
                    cb.Write(".Hook<PrefixDetour>(StateMachineTarget()");
                else
                    cb.Write(".Hook<PrefixDetour>(Target()");
                cb.WriteLine(", hook.Method, config, applyByDefault);")
                    .DecreaseIndent()
                    .DecreaseIndent()
                    .WriteLine();

                if (member.GenerateControlFlowVariants)
                {
                    cb.Write("public static ").Write(hookType).Write("<PrefixDetour> ");
                    if (forMoveNext)
                        cb.Write(
                            "ControlFlowPrefixMoveNext(ControlFlowPrefixMoveNextSignature hook, "
                        );
                    else
                        cb.Write("ControlFlowPrefix(ControlFlowPrefixSignature hook, ");
                    cb.WriteLine(
                            "global::MonoDetour.MonoDetourConfig? config = null, bool applyByDefault = true, global::MonoDetour.MonoDetourManager? manager = null) =>"
                        )
                        .IncreaseIndent()
                        .WriteLine(
                            "(manager ?? global::MonoDetour.HookGen.DefaultMonoDetourManager.Instance)"
                        )
                        .IncreaseIndent();
                    if (forMoveNext)
                        cb.Write(".Hook<PrefixDetour>(StateMachineTarget()");
                    else
                        cb.Write(".Hook<PrefixDetour>(Target()");
                    cb.WriteLine(", hook.Method, config, applyByDefault);")
                        .DecreaseIndent()
                        .DecreaseIndent()
                        .WriteLine();
                }

                if (warnIEnumerator)
                    PrintIEnumeratorWarning("MoveNextPostfix");

                cb.Write("public static ").Write(hookType).Write("<PostfixDetour> ");
                if (forMoveNext)
                    cb.Write("PostfixMoveNext(PostfixMoveNextSignature hook, ");
                else
                    cb.Write("Postfix(PostfixSignature hook, ");
                cb.WriteLine(
                        "global::MonoDetour.MonoDetourConfig? config = null, bool applyByDefault = true, global::MonoDetour.MonoDetourManager? manager = null) =>"
                    )
                    .IncreaseIndent()
                    .WriteLine(
                        "(manager ?? global::MonoDetour.HookGen.DefaultMonoDetourManager.Instance)"
                    )
                    .IncreaseIndent();
                if (forMoveNext)
                    cb.Write(".Hook<PostfixDetour>(StateMachineTarget()");
                else
                    cb.Write(".Hook<PostfixDetour>(Target()");
                cb.WriteLine(", hook.Method, config, applyByDefault);")
                    .DecreaseIndent()
                    .DecreaseIndent()
                    .WriteLine();

                if (warnIEnumerator)
                    PrintIEnumeratorWarning("ILHookMoveNext");

                cb.Write("public static ").Write(hookType).Write("<ILHookDetour> ILHook");
                if (forMoveNext)
                    cb.Write("MoveNext");
                cb.WriteLine(
                        "(global::MonoDetour.Cil.ILManipulationInfo.Manipulator manipulator, global::MonoDetour.MonoDetourConfig? config = null, bool applyByDefault = true, global::MonoDetour.MonoDetourManager? manager = null) =>"
                    )
                    .IncreaseIndent()
                    .WriteLine(
                        "(manager ?? global::MonoDetour.HookGen.DefaultMonoDetourManager.Instance)"
                    )
                    .IncreaseIndent();
                if (forMoveNext)
                    cb.Write(".ILHook(StateMachineTarget()");
                else
                    cb.Write(".ILHook(Target()");
                cb.WriteLine(", manipulator, config, applyByDefault);")
                    .DecreaseIndent()
                    .DecreaseIndent()
                    .WriteLine();
            }

            cb.Write("public static ")
                .Write("global::System.Reflection.MethodBase")
                .WriteLine(" Target()")
                .OpenBlock();

            if (type.Type.InnermostType.FqName.Contains('<'))
            {
                if (type.Type.InnermostType.AssemblyIdentityName is null)
                    throw new Exception(
                        "type.Type.InnermostType.AssemblyIdentityName is null but it was needed for unspeakable type"
                    );

                cb.Write("var type = global::System.Type.GetType(\"")
                    .Write(type.Type.InnermostType.MdName)
                    .Write(", ")
                    .Write(type.Type.InnermostType.AssemblyIdentityName)
                    .WriteLine("\");")
                    .Write("if (type is null) ");

                EmitThrowMissing(type, null, cb, ctx);
            }
            else
            {
                cb.Write("var type = typeof(")
                    .Write(type.Type.InnermostType.FqName)
                    .WriteLine(");");
            }

            cb.Write("var method = type.");

            if (member.IsCtor)
            {
                cb.Write("GetConstructor(");
            }
            else
            {
                cb.Write("GetMethod(\"").Write(member.Name).Write("\", ");
            }

            cb.Write("(global::System.Reflection.BindingFlags)~0").Write(", null, ");

            EmitOpenArray(cb, ctx, "global::System.Type");

            foreach (var param in member.Signature.ParameterTypes.AsImmutableArray())
            {
                if (param.FqName.Contains('<'))
                {
                    if (param.AssemblyIdentityName is null)
                        throw new Exception(
                            "type.Type.InnermostType.AssemblyIdentityName is null but it was needed for unspeakable type"
                        );

                    cb.Write("global::System.Type.GetType(\"")
                        .Write(param.MdName)
                        .Write(", ")
                        .Write(param.AssemblyIdentityName)
                        .Write("\")!");
                }
                else
                {
                    cb.Write("typeof(").Write(RemoveRefness(param.FqName)).Write(")");
                }
                if (!string.IsNullOrWhiteSpace(param.Refness))
                {
                    cb.Write(".MakeByRefType()");
                }
                cb.WriteLine(",");
            }

            EmitCloseArray(cb, ctx);

            cb.WriteLine(", null);").Write("if (method is null) ");
            EmitThrowMissing(type, member, cb, ctx);
            cb.WriteLine($"return method{(ctx.Bcl.DoesNotReturnAttribute ? "" : "!")};")
                .CloseBlock();

            if (member.Signature.IteratorStateMachine is not null)
            {
                cb.WriteLine()
                    .Write("public static ")
                    .Write("global::System.Reflection.MethodInfo")
                    .WriteLine(" StateMachineTarget() =>")
                    .IncreaseIndent()
                    .Write(
                        "global::MonoMod.Utils.Extensions.GetStateMachineTarget((global::System.Reflection.MethodInfo)Target())!;"
                    )
                    .DecreaseIndent()
                    .WriteLine();
            }

            cb.CloseBlock();
        }

        private static void EmitOpenArray(CodeBuilder cb, ContextSupportOptions ctx, string type)
        {
            if (ctx.Lang.CollectionExpressions)
            {
                cb.WriteLine("[").IncreaseIndent();
            }
            else
            {
                cb.Write("new ").Write(type).WriteLine("[]").OpenBlock();
            }
        }

        private static void EmitCloseArray(CodeBuilder cb, ContextSupportOptions ctx)
        {
            if (ctx.Lang.CollectionExpressions)
            {
                cb.DecreaseIndent().Write("]");
            }
            else
            {
                cb.DecreaseIndent().Write("}");
            }
        }

        private static string GetOrigDelegateName(MethodSignature sig)
        {
            return "Orig" + GetHookDelegateName(sig);
        }

        private static readonly ObjectPool<StringBuilder> stringBuilderPool = new(() => new());

        private static string SanitizeRefness(string v) => v.Replace(" ", "_");

        private static string RemoveRefness(string v) => v.Split(' ')[^1];

        private static string SanitizeMdName(string v) =>
            v.Replace(".", "_")
                .Replace("`", "_")
                .Replace("+", "_")
                .Replace("<", "_")
                .Replace(">", "_");

        private static string SanitizeUnspeakableFqName(string v)
        {
            if (v.Contains('<') || v.Contains('>'))
                return "object";

            return v;
        }

        private static string GetHookDelegateName(MethodSignature sig)
        {
            var sb = stringBuilderPool.Allocate();

            var parameters = sig.ParameterTypes.AsImmutableArray();
            sb.Append("HookSig_")
                .Append(SanitizeRefness(sig.ReturnType.Refness))
                .Append(SanitizeMdName(sig.ReturnType.MdName))
                .Append('_')
                .Append(parameters.Length);

            if (sig.ThisType is { } thisType)
            {
                _ = sb.Append('_')
                    .Append(SanitizeRefness(thisType.Refness))
                    .Append(SanitizeMdName(thisType.MdName));
            }

            for (var i = 0; i < parameters.Length; i++)
            {
                var param = parameters[i];

                _ = sb.Append('_')
                    .Append(SanitizeRefness(param.Refness))
                    .Append(SanitizeMdName(param.MdName));
            }

            var result = sb.ToString();
            sb.Clear();
            stringBuilderPool.Free(sb);
            return result;
        }

        private static void AppendSignatureIdentifier(CodeBuilder cb, MethodSignature sig)
        {
            var parameters = sig.ParameterTypes.AsImmutableArray();
            cb.Write("_")
                .Write(SanitizeRefness(sig.ReturnType.Refness))
                .Write(SanitizeMdName(sig.ReturnType.MdName))
                .Write('_')
                .Write(parameters.Length.ToString(CultureInfo.InvariantCulture));

            if (sig.ThisType is { } thisType)
            {
                _ = cb.Write('_')
                    .Write(SanitizeRefness(thisType.Refness))
                    .Write(SanitizeMdName(thisType.MdName));
            }

            for (var i = 0; i < parameters.Length; i++)
            {
                var param = parameters[i];

                _ = cb.Write('_')
                    .Write(SanitizeRefness(param.Refness))
                    .Write(SanitizeMdName(param.MdName));
            }
        }

        private static (
            EquatableArray<MethodSignature>,
            EquatableArray<TypeRef>
        ) ExtractSignaturesAndTypes(GeneratableAssembly assembly, CancellationToken token)
        {
            var sigSet = methodSigHashSetPool.Allocate();
            var typeSet = typeRefHashSetPool.Allocate();
            var queue = genTypeModelQueuePool.Allocate();

            foreach (var type in assembly.Types)
            {
                queue.Enqueue(type);
            }

            while (queue.Count > 0)
            {
                var type = queue.Dequeue();

                // add to the type set
                _ = typeSet.Add(type.Type.InnermostType.WithRefness());

                foreach (var method in type.Members)
                {
                    if (method.Kind != DetourKind.ILHook)
                    {
                        sigSet.Add(method.Signature);
                    }

                    _ = typeSet.Add(method.Signature.ReturnType.WithRefness());
                    foreach (var p in method.Signature.ParameterTypes)
                    {
                        _ = typeSet.Add(p.WithRefness());
                    }
                }

                foreach (var nested in type.NestedTypes)
                {
                    queue.Enqueue(nested);
                }
            }

            var methodSigs = sigSet.ToImmutableArray();
            var types = typeSet.ToImmutableArray();
            sigSet.Clear();
            typeSet.Clear();
            methodSigHashSetPool.Free(sigSet);
            typeRefHashSetPool.Free(typeSet);
            genTypeModelQueuePool.Free(queue);
            return (methodSigs, types);
        }

        private static bool MetadataReferenceEquals(MetadataReference a, MetadataReference b)
        {
            if (a is CompilationReference ca)
            {
                if (b is CompilationReference cb)
                {
                    return ca.Compilation == cb.Compilation;
                }
                return false;
            }
            return ReferenceEquals(a, b);
        }

        private sealed record AssemblyModel(
            MetadataReference Assembly,
            EquatableArray<TypeModel> Types
        )
        {
            public bool Equals(AssemblyModel other) =>
                MetadataReferenceEquals(Assembly, other.Assembly) && Types.Equals(other.Types);

            public override int GetHashCode()
            {
                var hc = new HashCode();
                if (Assembly is CompilationReference cr)
                {
                    hc.Add(cr.Compilation);
                }
                else
                {
                    hc.Add(Assembly);
                }
                hc.Add(Types);
                return hc.ToHashCode();
            }
        }

        private sealed record TypeModel(
            TypeContext TargetType,
            EquatableArray<AttributeModel> Attributes
        );

        private sealed record AttributeOptions(
            DetourKind Kind,
            bool IncludeNested,
            bool DistinguishOverloads,
            HashSet<string>? ExplicitMembers,
            EquatableArray<string> MemberPrefixes,
            EquatableArray<string> MemberSuffixes,
            bool GenerateControlFlowVariants
        )
        {
            public bool Equals(AttributeOptions other)
            {
                return Kind == other.Kind
                    && IncludeNested == other.IncludeNested
                    && DistinguishOverloads == other.DistinguishOverloads
                    && GenerateControlFlowVariants == other.GenerateControlFlowVariants
                    && MemberPrefixes.Equals(other.MemberPrefixes)
                    && MemberSuffixes.Equals(other.MemberSuffixes)
                    && (
                        (ExplicitMembers is null && other.ExplicitMembers is null)
                        || ExplicitMembers is not null
                            && other.ExplicitMembers is not null
                            && stringHashSetEqualityComparer.Equals(
                                ExplicitMembers,
                                other.ExplicitMembers
                            )
                    );
            }

            public override int GetHashCode()
            {
                var hc = new HashCode();
                hc.Add(Kind);
                hc.Add(IncludeNested);
                hc.Add(DistinguishOverloads);
                hc.Add(GenerateControlFlowVariants);
                hc.Add(MemberPrefixes);
                hc.Add(MemberSuffixes);
                if (ExplicitMembers is not null)
                {
                    hc.Add(stringHashSetEqualityComparer.GetHashCode(ExplicitMembers));
                }
                return hc.ToHashCode();
            }

            public bool MatchesName(string name)
            {
                if (ExplicitMembers is not null && ExplicitMembers.Contains(name))
                {
                    return true;
                }

                foreach (var prefix in MemberPrefixes)
                {
                    if (name.StartsWith(prefix, StringComparison.Ordinal))
                    {
                        return true;
                    }
                }

                foreach (var suffix in MemberSuffixes)
                {
                    if (name.EndsWith(suffix, StringComparison.Ordinal))
                    {
                        return true;
                    }
                }

                return ExplicitMembers is null && MemberPrefixes.IsEmpty && MemberSuffixes.IsEmpty;
            }
        }

        private sealed record AttributeModel(
            MetadataReference TargetAssembly,
            TypeContext TargetType,
            AttributeOptions Options
        )
        {
            public bool Equals(AttributeModel other) =>
                MetadataReferenceEquals(TargetAssembly, other.TargetAssembly)
                && TargetType.Equals(other.TargetType)
                && Options.Equals(other.Options);

            public override int GetHashCode()
            {
                var hc = new HashCode();
                if (TargetAssembly is CompilationReference cr)
                {
                    hc.Add(cr.Compilation);
                }
                else
                {
                    hc.Add(TargetAssembly);
                }
                hc.Add(TargetType);
                hc.Add(Options);
                return hc.ToHashCode();
            }
        }

        private static AttributeModel? ReadTypeModelForAttribute(
            Compilation compilation,
            ISymbol targetSym,
            AttributeData attr
        )
        {
            if (attr.ConstructorArguments is not [{ Value: INamedTypeSymbol targetType }])
                return null;

            var includeNested = true;
            var distinguishOverloads = false;
            bool generateControlFlowVariants = false;
            var kind = DetourKind.Hook;
            HashSet<string>? explicitMembers = null;
            var memberPrefixes = ImmutableArray<string>.Empty;
            var memberSuffixes = ImmutableArray<string>.Empty;

            foreach (var named in attr.NamedArguments)
            {
                switch (named.Key)
                {
                    case "Kind"
                        when named.Value is { Kind: TypedConstantKind.Enum, Value: int val }:
                        kind = (DetourKind)val;
                        if (
                            kind
                            is not DetourKind.Hook
                                and not DetourKind.ILHook
                                and not DetourKind.Both
                        )
                        {
                            return null;
                        }
                        break;
                    case "IncludeNestedTypes" when named.Value is { Value: bool bval }:
                        includeNested = bval;
                        break;
                    case "DistinguishOverloadsByName" when named.Value is { Value: bool bval }:
                        distinguishOverloads = bval;
                        break;
                    case "Members"
                        when named.Value is { Kind: TypedConstantKind.Array, Values: var values }:
                        explicitMembers = new HashSet<string>(
                            values.Select(c => c.Value as string).Where(s => s is not null)!
                        );
                        break;
                    case "MemberNamePrefixes"
                        when named.Value is { Kind: TypedConstantKind.Array, Values: var values }:
                        memberPrefixes = values
                            .Select(c => c.Value as string)
                            .Where(s => s is not null)
                            .ToImmutableArray()!;
                        break;
                    case "MemberNameSuffixes"
                        when named.Value is { Kind: TypedConstantKind.Array, Values: var values }:
                        memberSuffixes = values
                            .Select(c => c.Value as string)
                            .Where(s => s is not null)
                            .ToImmutableArray()!;
                        break;
                    case "GenerateControlFlowVariants"
                        when named.Value is { Value: bool isGenerateControlFlowVariants }:
                        generateControlFlowVariants = isGenerateControlFlowVariants;
                        break;

                    default:
                        return null;
                }
            }

            var mr = compilation.GetMetadataReference(targetType.ContainingAssembly);
            if (mr is null)
            {
                // presumably, this means it's in this assembly, so we don't care about it
                return null;
            }

            return new(
                mr,
                GenHelpers.CreateTypeContext(targetType, "namespace", SanitizeName),
                new(
                    kind,
                    includeNested,
                    distinguishOverloads,
                    explicitMembers,
                    memberPrefixes,
                    memberSuffixes,
                    generateControlFlowVariants
                )
            );
        }

        private sealed record GeneratableAssembly(EquatableArray<GeneratableTypeModel> Types);

        private sealed record GeneratableTypeModel(
            AssemblyIdentity AssemblyIdentity,
            TypeContext Type,
            EquatableArray<GeneratableTypeModel> NestedTypes,
            EquatableArray<GeneratableMemberModel> Members,
            bool HasHook,
            bool HasIl,
            bool NameIsSpeakable
        );

        private sealed record MethodSignature(
            TypeRef? ThisType,
            EquatableArray<TypeRef> ParameterTypes,
            TypeRef ReturnType,
            IteratorStateMachineTarget? IteratorStateMachine = null
        );

        private sealed record IteratorStateMachineTarget(
            TypeRef TargetType,
            TypeRef EnumeratorType,
            bool ThisField
        );

        private sealed record GeneratableMemberModel(
            string Name,
            MethodSignature Signature,
            bool DistinguishByName,
            bool HasOverloads,
            bool IsCtor,
            Accessibility Accessibility,
            DetourKind Kind,
            bool GenerateControlFlowVariants
        );

        // I'm OK putting this in the pipeline, because the IAssemblySymbol here will always represent a metadata reference.
        // The symbols for those are reused when possible, as far as I can tell.
        private static (AssemblyModel Model, IAssemblySymbol? Symbol) GetAssemblySymbol(
            (AssemblyModel Left, Compilation Right) tuple,
            CancellationToken token
        )
        {
            var symbol = tuple.Right.GetAssemblyOrModuleSymbol(tuple.Left.Assembly);
            if (symbol is IModuleSymbol module)
            {
                symbol = module.ContainingAssembly;
            }
            if (symbol is not IAssemblySymbol assembly)
            {
                return (tuple.Left, null);
            }
            return (tuple.Left, assembly);
        }

        private static GeneratableAssembly GetAllMembersToGenerate(
            (AssemblyModel Model, IAssemblySymbol Symbol) tuple,
            CancellationToken token
        )
        {
            using var generatableTypesBuilder = ImmutableArrayBuilder<GeneratableTypeModel>.Rent();

            var (model, assembly) = tuple;

            foreach (var type in model.Types)
            {
                var typeSym = assembly.GetTypeByMetadataName(type.TargetType.InnermostType.MdName);
                if (typeSym is null)
                    continue;

                var typeModel = GetTypeModel(type.TargetType, type.Attributes, typeSym, token);
                if (typeModel is not null)
                    generatableTypesBuilder.Add(typeModel);
            }

            return new(generatableTypesBuilder.ToImmutable());
        }

        private static GeneratableTypeModel? GetTypeModel(
            TypeContext typeContext,
            ImmutableArray<AttributeModel> attrModels,
            INamedTypeSymbol type,
            CancellationToken token
        )
        {
            token.ThrowIfCancellationRequested();

            // ignore generic types, they can't be patched reliably
            if (type.IsGenericType)
            {
                return null;
            }

            if (type.IsAnonymousType)
            {
                return null;
            }

            if (type.IsImplicitlyDeclared)
            {
                // TODO: maybe not this?
                return null;
            }

            using var membersBuilder = ImmutableArrayBuilder<GeneratableMemberModel>.Rent();
            using var typesBuilder = ImmutableArrayBuilder<GeneratableTypeModel>.Rent();

            bool hasHook = false,
                hasIl = false;

            // first, process non-type members
            foreach (var member in type.GetMembers())
            {
                if (member.Kind is not SymbolKind.Method or SymbolKind.Property)
                {
                    continue;
                }

                token.ThrowIfCancellationRequested();

                bool? alreadyMatchedWithDistinguishedOverloads = null;
                var hasOverloads = type.GetMembers(member.Name).Length > 1;

                foreach (var attr in attrModels)
                {
                    var options = attr.Options;

                    if (
                        alreadyMatchedWithDistinguishedOverloads is { } matchVal
                        && matchVal == options.DistinguishOverloads
                    )
                    {
                        // we already matched this member with this distinguishOverloads value, skip
                        continue;
                    }

                    if (!options.MatchesName(member.Name))
                    {
                        continue;
                    }

                    GeneratableMemberModel? model = null;

                    // the member matched, do our processing
                    if (member.Kind is SymbolKind.Property)
                    {
                        var prop = (IPropertySymbol)member;

                        if (prop.GetMethod is { } getMethod)
                        {
                            model = GetModelForMember(getMethod, options, hasOverloads);
                        }
                        if (prop.SetMethod is { } setMethod)
                        {
                            model = GetModelForMember(setMethod, options, hasOverloads);
                        }
                    }
                    else if (member.Kind is SymbolKind.Method)
                    {
                        var method = (IMethodSymbol)member;
                        model = GetModelForMember(method, options, hasOverloads);
                    }

                    if (model is not null)
                    {
                        membersBuilder.Add(model);
                        hasHook |= options.Kind != DetourKind.ILHook;
                        hasIl |= options.Kind != DetourKind.Hook;
                    }

                    if (alreadyMatchedWithDistinguishedOverloads is not null)
                    {
                        // we matched with both, no need to continue
                        break;
                    }
                    else
                    {
                        alreadyMatchedWithDistinguishedOverloads = options.DistinguishOverloads;
                    }
                }
            }

            // then, process type members
            foreach (var attr in attrModels)
            {
                var options = attr.Options;

                if (!options.IncludeNested)
                {
                    continue;
                }

                foreach (var nested in type.GetTypeMembers())
                {
                    token.ThrowIfCancellationRequested();

                    if (!options.MatchesName(nested.Name))
                    {
                        continue;
                    }

                    var typeModel = GetTypeModel(
                        GenHelpers.CreateTypeContext(nested, "class", SanitizeName),
                        ImmutableArray.Create(attr),
                        nested,
                        token
                    );
                    if (typeModel is not null)
                    {
                        typesBuilder.Add(typeModel);
                        hasHook |= typeModel.HasHook;
                        hasIl |= typeModel.HasIl;
                    }
                }
            }

            return new(
                type.ContainingAssembly.Identity,
                typeContext,
                typesBuilder.ToImmutable(),
                membersBuilder.ToImmutable(),
                hasHook,
                hasIl,
                type.CanBeReferencedByName
            );
        }

        private static GeneratableMemberModel? GetModelForMember(
            IMethodSymbol method,
            AttributeOptions options,
            bool hasOverloads
        )
        {
            // skip generic methods
            if (method.IsGenericMethod)
            {
                return null;
            }

            if (method.IsAbstract)
            {
                return null;
            }

            using var paramTypeBuilder = ImmutableArrayBuilder<TypeRef>.Rent();

            foreach (var param in method.Parameters)
            {
                paramTypeBuilder.Add(GenHelpers.CreateRef(param));
            }

            var returnType = GenHelpers.CreateRef(
                method.ReturnType,
                GenHelpers.GetRefString(method.RefKind, isReturn: true)
            );

            TypeRef? thisType = null;
            if (!method.IsStatic)
            {
                var refKind = method.ContainingType.IsValueType
                    ? (method.IsReadOnly ? RefKind.RefReadOnly : RefKind.Ref)
                    : RefKind.None;

                thisType = GenHelpers.CreateRef(
                    method.ContainingType,
                    GenHelpers.GetRefString(refKind, false)
                );
            }

            IteratorStateMachineTarget? iteratorStateMachine = null;

            foreach (var attribute in method.GetAttributes())
            {
                var attributeClass = attribute.AttributeClass;
                if (attributeClass is null)
                {
                    continue;
                }

                if (
                    !attributeClass
                        .ToDisplayString()
                        .Equals("System.Runtime.CompilerServices.IteratorStateMachineAttribute")
                )
                {
                    continue;
                }

                if (attribute.ConstructorArguments[0].Value is not ITypeSymbol targetType)
                {
                    continue;
                }
                var enumeratorType = targetType.Interfaces.First(x =>
                    x.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
                        .StartsWith("global::System.Collections.Generic.IEnumerator<")
                );
                var typeArgs = enumeratorType.TypeArguments;
                if (typeArgs.Length != 1)
                {
                    throw new Exception($"enumerator Type has {typeArgs.Length} type arguments!");
                }

                bool hasThisField = targetType
                    .GetMembers()
                    .OfType<IFieldSymbol>()
                    .Any(f => f.Name.Equals("<>4__this"));

                iteratorStateMachine = new(
                    GenHelpers.CreateRef(targetType),
                    GenHelpers.CreateRef(typeArgs[0]),
                    hasThisField
                );
            }

            var sig = new MethodSignature(
                thisType,
                paramTypeBuilder.ToImmutable(),
                returnType,
                iteratorStateMachine
            );

            return new(
                method.Name,
                sig,
                options.DistinguishOverloads && hasOverloads,
                hasOverloads,
                method.MethodKind is MethodKind.Constructor or MethodKind.StaticConstructor,
                method.DeclaredAccessibility,
                options.Kind,
                options.GenerateControlFlowVariants
            );
        }

        private static string SanitizeName(string name)
        {
            if (string.IsNullOrEmpty(name))
                return string.Empty;

            var result = name.Replace('.', '_')
                .Replace('/', '_')
                .Replace('`', '_')
                .Replace('+', '_')
                .Replace('<', '_')
                .Replace('>', '_')
                .Replace('$', '_');

            /*
            if (result != name) {
                result = "_S_" + result;
            }
            */

            if (result[0] is >= '0' and <= '9')
            {
                result = "@" + result;
            }

            return result;
        }
    }
}
